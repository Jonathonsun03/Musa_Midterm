---
title: "Hedonic Home Price Prediction"
author: "Jonathon Sun, Johnathan Clementi a.k.a. John^2"
date: "9/29/2021"
output: 
  html_document:
    code_folding: hide
    toc: TRUE
    toc_float: TRUE
---


```{r setup, include=FALSE, message=FALSE, warning=FALSE}

knitr::opts_chunk$set(warning = FALSE)
pacman::p_load(caret, ckanr, FNN, ggcorplot, grid, gridExtra, httr, kableExtra, modelsummary, tidyverse, tidycensus, sf,  spdep, tmap, viridis,  zipcodeR)
library(ggcorrplot)

options(scipen =  "sf")
options(scipen = 999)

source("https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/functions.r")

palette5 <- c("#25CB10", "#5AB60C", "#8FA108",   "#C48C04", "#FA7800")
```

# Introduction
  The intent of this report is to use local intelligence to improve zillow's predictive model utilizing only OLS regression. What we did to improve the model was include [INSERT VARAIBLES HERE].

# Data
  We were first given a dataset that included housing prices and the points where they were located. From here, we decided to organize our data between fixed-effect and nearest neighbors. Fixed-effects take into consideration points that lie within a designated boundary. For example, all houses in a particular zip code would undergo a similar fixed-effect because they all inhabit that zip code. In contrast, the nearest neighbor calculates the distance between two points and takes the average of those distances by nearest neighbor value.

## Home prices dataset
```{r housedata, message=FALSE, warning=FALSE, include=FALSE, results='hold', results = 'hide'}
# Set CRS for project
CO_statePlaneCentral = "ESRI:102254"

studentData <- st_read("studentData.geojson", crs = CO_statePlaneCentral) %>%
  mutate(pricePerSF = price/TotalFinishedSF,
         age = 2021 - builtYear,
         iprvmntAge = EffectiveYear - builtYear) %>%
  # Change NA address values to something R won't get rid of when we do na.omit()
  mutate(address=replace_na(address,"No address given")) %>%
  # Remove numeric categorical vars - there are already descriptions for these values in the df
  dplyr::select(-Stories, -UnitCount, -Ac, -Heating, -ExtWallPrim, -ExtWallSec, -IntWall, -Roof_Cover, -status_cd) %>%
  st_transform(CO_statePlaneCentral) 

studentData$pricePerSF <- as.integer(studentData$pricePerSF)

# Check to see we aren't loosing records
# testTrain <- studentData.training %>% na.omit()
# addition <- rbind(studentData.training,testTrain)
# difference <- addition[! duplicated(addition, fromLast = TRUE) & seq(nrow(addition)) <= nrow(studentData.training), ]
```

## Fixed Effects 

The fixed effects data that we selected include the 2019 census tract data, bounder county school districts, Boulder City limits and Boulder county zip codes. These are all fixed effects as the represent spaces that the points inhabit and are shaped by. SOme of these fixed effects will be engineered to provide more in depth analysis

### Census 2019
The first fixed effect variables that we looked at was census tract. With the census tract data we pulled variables on Race and Median age. Race was important as a fixed effect to predict housing price, people with similar racial categories often move into similar spaces. Age was important, because people may be interested moving into areas with similarly aged people. 

```{r tidycensus_2019, message=FALSE, warning=FALSE, include=FALSE, results='hold'}

#variables on frequency of Race
Variables <- load_variables(2019,
                            "acs5",
                            cache = TRUE) %>%
  mutate(Merge_name = paste(name,"E", sep ="")) %>%
  filter(grepl("RACE", concept)) %>%
  filter(!grepl("AGE", concept)) %>%
  slice(1:10)

#variable median age, men and women not by race
A <- load_variables(2019,
                    "acs5",
                    cache = TRUE) %>%
  mutate(Merge_name = paste(name,"E", sep ="")) %>%
  filter(grepl("MEDIAN", concept)) %>%
  slice(1:3)

#Median Household Income
B <- load_variables(2019,
                    "acs5",
                    cache = TRUE) %>%
  mutate(Merge_name = paste(name,"E", sep ="")) %>%
  filter(grepl("MEDIAN INCOME", concept)) %>%
  slice(1)

# Cost of living
C <- load_variables(2019,
                    "acs5",
                    cache = TRUE) %>%
  mutate(Merge_name = paste(name,"E", sep ="")) %>%
  filter(grepl("COST", concept)) %>%
  slice(1:19)

Variables <- bind_rows(Variables, A, B, C)

# Pull census data using tidycensus
# Read in census tracts

acsTractsCol.2019.sf <- get_acs(geography = "tract",
        year = 2019,
        variables = Variables$name, 
        state="Colorado",
        county= c("Boulder"),
        geometry=T,
        output = "wide") %>% 
  st_transform(CO_statePlaneCentral)%>%
  dplyr::select (GEOID, NAME, all_of(paste0(Variables$name,"E"))) %>%
  rename(Total_pop = Variables$Merge_name[1],
         White_pop = Variables$Merge_name[2],
         Black_pop = Variables$Merge_name[3],
         American_Indian_pop = Variables$Merge_name[4],
         Asian_pop = Variables$Merge_name[5],
         Hawiian_PI_pop = Variables$Merge_name[6],
         OtherRace_pop = Variables$Merge_name[7],
         two_or_more_pop = Variables$Merge_name[8],
         two_other_pop = Variables$Merge_name[9],
         two_or_more_exclude_pop = Variables$Merge_name[10],
         Median_age = Variables$Merge_name[11],
         Median_Male_age = Variables$Merge_name[12],
         Median_Female_age = Variables$Merge_name[13],
         MortgagesTotal_mortgage = Variables$Merge_name[14],
         MortgagesHas_mortgage = Variables$Merge_name[15],
         Mortgage200Less_mortgage = Variables$Merge_name[16],
         Mortgage200_299_mortgage = Variables$Merge_name[17],
         Mortgage300_399_mortgage = Variables$Merge_name[18],
         Mortgage400_499_mortgage = Variables$Merge_name[19],
         Mortgage500_599_mortgage = Variables$Merge_name[20],
         Mortgage600_699_mortgage = Variables$Merge_name[21],
         Mortgage700_799_mortgage = Variables$Merge_name[22],
         Mortgage800_899_mortgage = Variables$Merge_name[23],
         Mortgage900_999_mortgage = Variables$Merge_name[24],
         Mortgage1000_1249_mortgage = Variables$Merge_name[25],
         Mortgage1250_1499_mortgage = Variables$Merge_name[26],
         Mortgage1500_1999_mortgage = Variables$Merge_name[27],
         Mortgage2000_2499_mortgage = Variables$Merge_name[28],
         Mortgage2500_2999_mortgage = Variables$Merge_name[29],
         Mortgage3000_3499_mortgage = Variables$Merge_name[30],
         Mortgage3500_3999_mortgage = Variables$Merge_name[31],
         Mortgage3750_3999_mortgage = Variables$Merge_name[32],
         Mortgage4000_mortgage = Variables$Merge_name[33]) 
         

acsTractsCol.2019.sf <- mutate(acsTractsCol.2019.sf, TractID = row_number())

  ggplot() +
  geom_sf(data = acsTractsCol.2019.sf)

# Read in census Block groups
 acsBGCol.2019.sf <- get_acs(geography = "block group",
         year = 2019,
         variables = Variables$name, 
         state="Colorado",
         county= c("Boulder"),
         geometry=T,
         output = "wide") %>% 
   st_transform(CO_statePlaneCentral) %>%
   dplyr::select (GEOID, NAME, all_of(paste0(Variables$name,"E")))
 
 ggplot() +
   geom_sf(data = acsBGCol.2019.sf)+
   labs(title = "Census Block Groups, Boulder County, Colorado")

 
 # Assign a school district to each home
# Help document: https://gis.stackexchange.com/questions/133625/checking-if-points-fall-within-polygon-shapefile
studentData <- studentData %>%
  mutate(
    TractID = as.integer(st_intersects(geometry,acsTractsCol.2019.sf)))
    #,
    #schoolDist_name = if_else(is.na(District), "", acsSchoolDistrctssCol.2019.sf$NAME[District])

```

### Boulder City Fixed Effect

Lastly we thought it would be important to consider which points were within Boulder City limits. These points were engineered to consider if they were or were not within the city limits. 
```{r city_Limits1}
boulderCityLimits <- st_read("https://opendata.arcgis.com/datasets/955e7a0f52474b60a9866950daf10acb_0.geojson") %>%
  st_transform(st_crs(acsTractsCol.2019.sf)) %>%
  mutate(inCity = 1)

# Determine if a house is within the city or not - used for cases in which only city data is available
studentData <- studentData %>%
  mutate(withinCity = as.integer(st_intersects(geometry,boulderCityLimits)))

studentData <- studentData %>%
  mutate(withinCity = replace_na(withinCity,"0"))

# Change 
studentData <- studentData %>%
  mutate(withinCity = ifelse(withinCity > 0, 1, 0))
```

### Boulder County School Districts

Another fixed effect that was included in the analysis was school distrct. The assumption that is being made with school district is that potential homebuyers value general education and they believe that education will increase their own, or their children, human capital. School district data was also pulled from the American Community Survey data and overlapped by census tracts to ensure all the correct locations were used. Each point from the dataset was then assigned to a particular district.

```{r school_districts, message=FALSE, warning=FALSE, include=FALSE}
#Unified School District
acsSchoolDistrctssCol.2019.sf <- get_acs(geography = "school district (unified)",
        year = 2019,
        variables = Variables$name, 
        state="Colorado",
        geometry=T,
        output = "wide") %>% 
  st_transform(CO_statePlaneCentral) %>%
  dplyr::select (GEOID, NAME, all_of(paste0(Variables$name,"E")))


school_districts <- st_overlaps(st_union(acsTractsCol.2019.sf), acsSchoolDistrctssCol.2019.sf)
acsSchoolDistrctssCol.2019.sf <- acsSchoolDistrctssCol.2019.sf %>%
  slice(school_districts[[1]])

acsSchoolDistrctssCol.2019.sf <- mutate(acsSchoolDistrctssCol.2019.sf, id = row_number())


# Assign a school district to each home
# Help document: https://gis.stackexchange.com/questions/133625/checking-if-points-fall-within-polygon-shapefile
studentData <- studentData %>%
  mutate(
    District = paste0("District",as.integer(st_intersects(geometry,acsSchoolDistrctssCol.2019.sf)))
    #,
    #schoolDist_name = if_else(is.na(District), "", acsSchoolDistrctssCol.2019.sf$NAME[District])
  )


#ggplot() +
#  geom_sf(data = acsSchoolDistrctssCol.2019.sf,
#          fill = "red") +
#  geom_sf(data = st_union(acsTractsCol.2019.sf),
#         fill = "transparent")
```

### Boulder County Zip codes

Most people are not aware of what census tract they live in; however, census tract data provides more detail then zip codes do. As such we thought it was important to analyze the prices in each zip code. Zipcodes are also strong predictors of future economic outcomes.  

```{r Zip_codes, warning=FALSE, results='hide'}

#Zip Code
acsZipsCol.2019.sf <- get_acs(geography = "zcta",
        year = 2019,
        variables = Variables$name, 
        geometry=T,
        output = "wide") %>% 
  st_transform(CO_statePlaneCentral) %>%
  dplyr::select (GEOID, NAME, all_of(paste0(Variables$name,"E"))) 


acsZipsCol.2019.sf <- acsZipsCol.2019.sf %>%
  st_intersection(st_union(acsTractsCol.2019.sf)) %>%
  st_sf()

# # boulderCo_flood <- COState_flood %>%
# #   st_intersection(st_union(acsTractsCol.2019.sf)) %>%
# #   st_sf()


ggplot() +
  geom_sf(data = acsZipsCol.2019.sf) +
  geom_sf(data = studentData)

# zuocodeR package
acsZipsCol.2019 <- search_county('Boulder', 'CO') 

#ggplot() +
#  geom_sf(data = acsZipsCol.2019)

# Assign a zipcode to each home
# Help document: https://gis.stackexchange.com/questions/133625/checking-if-points-fall-within-polygon-shapefile
studentData <- studentData %>%
  mutate(
    Zip = paste0("Zip",as.integer(st_intersects(geometry,acsZipsCol.2019.sf)))
    #zipcode = if_else(is.na(Zip), "", acsSchoolDistrctssCol.2019.sf$NAME[Zip])
  ) 

ggplot() +
  geom_sf(data = acsZipsCol.2019.sf) +
  labs(title = "Zip Tracts, Boulder County, Colorado")
```

## Point Data
Although it is possible to pull buffered data to analyze data by fixed effects, the fixed effect data is often categorical or binaried and does not provide the nuance in building a model. To rememdy this, we selected found point data on floods, Amernities, Public Services and Education resources nearby. The benefit of this point data is that numeric data can be used in the model to provide more detail.

### Flood Data
Other factors that were considered in this analysis was flood plain data. Flood plain data takes into consideration how close the nearest flood point is. [JC]

Website available for data https://open-data.bouldercolorado.gov/ 
```{r floodplains}
# Locations of 100 Year floodplain within Boulder County
# Data originally for the whole state, subsetted to Boulder County via st_intersect
## https://geo.colorado.edu/catalog/47540-5ca228ffd43267000b8c7448
## About this dataset: https://open-data.bouldercolorado.gov/datasets/bfc343d63cf54831810b983b36ce6872_3/about

# # Process for creating Boulder County Flood Plains shp
# COState_flood <- st_read("CO_state_100yrFloodplains.geojson") %>%
#   st_transform(CO_statePlaneCentral)
#
# boulderCo_flood <- COState_flood %>%
#   st_intersection(st_union(acsTractsCol.2019.sf)) %>%
#   st_sf()
#
# # Create Geopackage for ease of transport - only one file
# st_write(boulderCo_flood, "boulderCo_100yrFloodZones.gpkg")

boulderCo_flood_gpkg <- st_read("boulderCo_100yrFloodZones.gpkg")

# Convert floodplain polygons to polylines
flood_boundaries <- st_boundary(boulderCo_flood_gpkg)

# Sample flood boundaries to get point data (used to pass to the nearest neighbor function)
flood_pts <- st_sample(flood_boundaries, size = 500, type = 'regular')
flood_pts <- st_cast(flood_pts, 'POINT')

ggplot() +
  geom_sf(data = st_union(acsTractsCol.2019.sf),
          fill = "transparent") +
  geom_sf(data = flood_pts, aes(color = "Blue")) +
  geom_sf(data = studentData)

```

### Amenities
Amenity data was selected from Data Axle, and includes institutions such as groceries, restaurants, shopping mapps, and recreational institutions. We thought that these institutions are not necessarily pubilc services, but provide benefits to the communities lifestyle.

### Public Services
Public services include hospitals, police departments, and fire departments. Although hospitals may not necessarily be public not-for-profit institutions, we thought it was important to include because of the impact that they have on public health and wellbeing of the community.

### Education
Educational variables included variables that provide educational benefits to the community. This primarily include public and private schools, neighborhoods and universities. There is no weighted system that distinguishes the different types of educational institution in this dataset. 

```{r} 
# # Locations of Zoning districts
# ## https://open-data.bouldercolorado.gov/datasets/e88004e26b9e42cfba32129fb8731f41_0/explore?location=40.025701%2C-105.239775%2C11.45
# ## City of Boulder Colorado Zoning Districts. Including residential, business, industrial, public, agricultural, mix of residential and business, residential mobile homes, main street area and mixed density residential.
# zoning <- st_read("https://opendata.arcgis.com/datasets/e88004e26b9e42cfba32129fb8731f41_0.geojson") %>%
#   st_transform(CO_statePlaneCentral)
# 
# ggplot() +
#   geom_sf(data = st_union(acsTractsCol.2019.sf),
#           fill = "transparent") +
#   geom_sf(data = zoning) +
#   labs(title = "Zoning Districts")


# Locations of 19 libraries 
## https://opendata-bouldercounty.hub.arcgis.com/datasets/libraries-2/explore?location=40.001009%2C-105.302539%2C11.28
Col_Library <- st_read("https://opendata.arcgis.com/datasets/7f4ea25ba87345e380d2e896611d2588_0.geojson") %>%
  st_transform(st_crs(acsTractsCol.2019.sf)) %>%
  select(c(Name, geometry))

Buffer_Library <- st_buffer(Col_Library, 10560) %>%
      mutate(Legend = "Buffer") %>%
      dplyr::select(Legend)

UnionBuffer_Library <- st_union(Buffer_Library)


ggplot() +
  geom_sf(data = st_union(acsTractsCol.2019.sf),
          fill = "transparent") +
  geom_sf(data = Col_Library) +
  geom_sf(data = UnionBuffer_Library,
          fill = "transparent") +
  labs(title = "library")

```
 
 
```{r, results='hold'}
# Grocery Stores from Data Axle
Grocery_Store <- read.csv("DataAxle_GroceryStores.csv") %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326, agr = "constant") %>%
  st_transform(CO_statePlaneCentral) 

Buffer_Grocery <- st_buffer(Grocery_Store, 5280) %>%
      mutate(Legend = "Buffer") %>%
      dplyr::select(Legend)

#Buffer_Grocery_Union <- st_union(st_buffer(Grocery_Store, 5280) %>%
#      mutate(Legend = "Buffer") %>%
#      dplyr::select(Legend))

#ggplot() +
#  geom_sf(data = st_union(acsTractsCol.2019.sf),
#          fill = "transparent") +
#  geom_sf(data = Grocery_Store) +
#    geom_sf(data = Buffer_Grocery,
#          fill = "transparent") +
#  labs(title = "Grocery_Stores")

#Grocery.rings <-
#  st_join(st_centroid(dplyr::select(studentData, address)), 
#          multipleRingBuffer(Buffer_Grocery, 5280, 2640)) %>%
#  st_drop_geometry() %>%
#  left_join(dplyr::select(studentData, address), 
#            by=c("address"="address")) %>%
#  st_sf()

#Restaurants from DataAxle
Restaurants <- bind_rows(read.csv("DataAxle_Restaurants_1.csv"), read.csv("DataAxle_Restaurants_2.csv")) %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326, agr = "constant") %>%
  st_transform(CO_statePlaneCentral)

#Buffer_Restaurants <- st_union(st_buffer(Restaurants, 5280) %>%
#      mutate(Legend = "Buffer") %>%
#      dplyr::select(Legend))


#ggplot() +
#  geom_sf(data = st_union(acsTractsCol.2019.sf),
#          fill = "transparent") +
#  geom_sf(data = Restaurants) +
#    geom_sf(data = Buffer_Restaurants,
#          fill = "transparent") +
#  labs(title = "Restaurants")

#Education from DataAxle
Education <- read.csv("DataAxle_Education.csv") %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326, agr = "constant") %>%
  st_transform(CO_statePlaneCentral)

Buffer_Education <- st_union(st_buffer(Education, 5280) %>%
      mutate(Legend = "Buffer") %>%
      dplyr::select(Legend))


#Museums from DataAxle
Museums <- read.csv("DataAxle_Musuems.csv") %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326, agr = "constant") %>%
  st_transform(CO_statePlaneCentral)

Buffer_Museums <- st_union(st_buffer(Museums, 5280) %>%
      mutate(Legend = "Buffer") %>%
      dplyr::select(Legend))

###############################
# New Features as of 10.19.2021

#Recreation businesses from DataAxle
Recreation <- read.csv("DataAxle_Recreation.csv") %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326, agr = "constant") %>%
  st_transform(CO_statePlaneCentral)

Buffer_Recreation <- st_union(st_buffer(Recreation, 5280) %>%
      mutate(Legend = "Buffer") %>%
      dplyr::select(Legend))

#Police departments from DataAxle
PoliceDepartments <- read.csv("DataAxle_PoliceDepartments.csv") %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326, agr = "constant") %>%
  st_transform(CO_statePlaneCentral)

Buffer_PoliceDepartments <- st_union(st_buffer(PoliceDepartments, 5280) %>%
      mutate(Legend = "Buffer") %>%
      dplyr::select(Legend))

#Fire and EMT departments from DataAxle
FireandEMT <- read.csv("DataAxle_FireandEMT.csv") %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326, agr = "constant") %>%
  st_transform(CO_statePlaneCentral)

Buffer_FireandEMT <- st_union(st_buffer(FireandEMT, 5280) %>%
      mutate(Legend = "Buffer") %>%
      dplyr::select(Legend))

#Hospitals from DataAxle
Hospitals <- read.csv("DataAxle_Hospitals.csv") %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326, agr = "constant") %>%
  st_transform(CO_statePlaneCentral)

Buffer_Hospitals <- st_union(st_buffer(Hospitals, 5280) %>%
      mutate(Legend = "Buffer") %>%
      dplyr::select(Legend))

#ShoppingMalls from DataAxle
ShoppingMalls <- read.csv("DataAxle_ShoppingMalls.csv") %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326, agr = "constant") %>%
  st_transform(CO_statePlaneCentral)

Buffer_ShoppingMalls <- st_union(st_buffer(ShoppingMalls, 5280) %>%
      mutate(Legend = "Buffer") %>%
      dplyr::select(Legend))

#Marijuana Dispensaries from DataAxle
Dispensaries <- read.csv("DataAxle_MarijuanaDispensaries.csv") %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326, agr = "constant") %>%
  st_transform(CO_statePlaneCentral)

Buffer_Dispensaries <- st_union(st_buffer(Dispensaries, 5280) %>%
      mutate(Legend = "Buffer") %>%
      dplyr::select(Legend))



``` 
 
# Feature Engineering

Once all the data was imported, the data was then transformed into a variety of ways to understand fixed effects and geographic distances.

### Census Tracts by Race
To utilize the census tracts these data were transformed into quartiles. The census tracts would represent the frequency of racial populations in that area. For example, for `White_quartile` column would predict for a specific quartile is the price, higher or lower. The same can be applied to other racial categories as well. 

```{r include=FALSE, results='hold'}

acsTractsCol.2019.sf <- acsTractsCol.2019.sf %>% 
  mutate(White_Quartile = q5(acsTractsCol.2019.sf$White_pop),
         Black_Quartile = q5(acsTractsCol.2019.sf$Black_pop),
         Asian_Quartile = q5(acsTractsCol.2019.sf$Asian_pop),
         American_Indian_Quartile = q5(acsTractsCol.2019.sf$American_Indian_pop),
         Hawiian_PI_Quartile = q5(acsTractsCol.2019.sf$Hawiian_PI_pop),
         OtherRace_Quartile = q5(acsTractsCol.2019.sf$OtherRace_pop),
         two_or_more_Quartile = q5(acsTractsCol.2019.sf$two_or_more_pop),
         two_other_Quartile = q5(acsTractsCol.2019.sf$two_other_pop),
         two_or_more_exclude_Quartile = q5(acsTractsCol.2019.sf$two_or_more_exclude_pop))


studentData <- left_join(studentData, acsTractsCol.2019.sf %>%
  select(TractID, ends_with("_Quartile")) %>%
    st_drop_geometry(), by = "TractID")

studentData <- left_join(studentData, acsTractsCol.2019.sf %>%
  select(TractID, ends_with("_age")) %>%
    st_drop_geometry(), by = "TractID")
```


## Feature Engineering

#### Buffers

Data from DataAxle was brought in to show the nearest grocery stores, restaurants, educational institutions, museums, recreational institutions, police departments, fire departments, medical facilitaties, shopping malls, and dispensaries. These were separated into three categories, 

### Nearest Neighbors
Each of these points were then used to find the five nearest neighbor value using the `nn_function`. Nn1 columns shows the distance to the direct nearest neighbor, the second takes the average distance of the two nearest neighbors, the third takes the average distanve of the three nearest neighbors and so on.  

```{r message=FALSE, warning=FALSE, include=FALSE, results='hold'}
## grovery Nearest Neighbor
st_c <- st_coordinates

## restaurante NN
studentData <- studentData %>%
  mutate(amenities_grocery_nn1 = nn_function(st_c(studentData), st_c(Grocery_Store), 1),
         amenities_grocery_nn2 = nn_function(st_c(studentData), st_c(Grocery_Store), 2),
         amenities_grocery_nn3 = nn_function(st_c(studentData), st_c(Grocery_Store), 3),
         amenities_grocery_nn4 = nn_function(st_c(studentData), st_c(Grocery_Store), 4),
         amenities_grocery_nn5 = nn_function(st_c(studentData), st_c(Grocery_Store), 5))

studentData <- studentData %>%
  mutate(amenities_restaurant_nn1 = nn_function(st_c(studentData), st_c(Restaurants), 1),
         amenities_restaurant_nn2 = nn_function(st_c(studentData), st_c(Restaurants), 2),
         amenities_restaurant_nn3 = nn_function(st_c(studentData), st_c(Restaurants), 3),
         amenities_restaurant_nn4 = nn_function(st_c(studentData), st_c(Restaurants), 4),
         amenities_restaurant_nn5 = nn_function(st_c(studentData), st_c(Restaurants), 5))

studentData <- studentData %>%
  mutate(Edu_Education_nn1 = nn_function(st_c(studentData), st_c(Education), 1),
         Edu_Education_nn2 = nn_function(st_c(studentData), st_c(Education), 2),
         Edu_Education_nn3 = nn_function(st_c(studentData), st_c(Education), 3),
         Edu_Education_nn4 = nn_function(st_c(studentData), st_c(Education), 4),
         Edu_Education_nn5 = nn_function(st_c(studentData), st_c(Education), 5))

studentData <- studentData %>%
  mutate(Edu_Museums_nn1 = nn_function(st_c(studentData), st_c(Museums), 1),
         Edu_Museums_nn2 = nn_function(st_c(studentData), st_c(Museums), 2),
         Edu_Museums_nn3 = nn_function(st_c(studentData), st_c(Museums), 3),
         Edu_Museums_nn4 = nn_function(st_c(studentData), st_c(Museums), 4),
         Edu_Museums_nn5 = nn_function(st_c(studentData), st_c(Museums), 5))


studentData <- studentData %>%
  mutate(SS_floodpts_nn1 = nn_function(st_c(studentData), st_c(flood_pts), 1),
         floodpts_nn2 = nn_function(st_c(studentData), st_c(flood_pts), 2),
         floodpts_nn3 = nn_function(st_c(studentData), st_c(flood_pts), 3),
         floodpts_nn4 = nn_function(st_c(studentData), st_c(flood_pts), 4),
         floodpts_nn5 = nn_function(st_c(studentData), st_c(flood_pts), 5))

studentData <- studentData %>%
  mutate(Edu_Library_nn1 = nn_function(st_c(studentData), st_c(Col_Library), 1),
         Edu_Library_nn2 = nn_function(st_c(studentData), st_c(Col_Library), 2),
         Edu_Library_nn3 = nn_function(st_c(studentData), st_c(Col_Library), 3),
         Edu_Library_nn4 = nn_function(st_c(studentData), st_c(Col_Library), 4),
         Edu_Library_nn5 = nn_function(st_c(studentData), st_c(Col_Library), 5))


studentData <- studentData %>%
  mutate(amenities_recreation_nn1 = nn_function(st_c(studentData), st_c(Recreation), 1),
         amenities_recreation_nn2 = nn_function(st_c(studentData), st_c(Recreation), 2),
         amenities_recreation_nn3 = nn_function(st_c(studentData), st_c(Recreation), 3),
         amenities_recreation_nn4 = nn_function(st_c(studentData), st_c(Recreation), 4),
         amenities_recreation_nn5 = nn_function(st_c(studentData), st_c(Recreation), 5))

studentData <- studentData %>%
  mutate(PS_pd_nn1 = nn_function(st_c(studentData), st_c(PoliceDepartments), 1),
         PS_pd_nn2 = nn_function(st_c(studentData), st_c(PoliceDepartments), 2),
         PS_pd_nn3 = nn_function(st_c(studentData), st_c(PoliceDepartments), 3),
         PS_pd_nn4 = nn_function(st_c(studentData), st_c(PoliceDepartments), 4),
         PS_pd_nn5 = nn_function(st_c(studentData), st_c(PoliceDepartments), 5))

studentData <- studentData %>%
  mutate(PS_fd_emt_nn1 = nn_function(st_c(studentData), st_c(FireandEMT), 1),
         PS_fd_emt_nn2 = nn_function(st_c(studentData), st_c(FireandEMT), 2),
         PS_fd_emt_nn3 = nn_function(st_c(studentData), st_c(FireandEMT), 3),
         PS_fd_emt_nn4 = nn_function(st_c(studentData), st_c(FireandEMT), 4),
         PS_fd_emt_nn5 = nn_function(st_c(studentData), st_c(FireandEMT), 5))

studentData <- studentData %>%
  mutate(PS_hospitals_nn1 = nn_function(st_c(studentData), st_c(Hospitals), 1),
         PS_hospitals_nn2 = nn_function(st_c(studentData), st_c(Hospitals), 2),
         PS_hospitals_nn3 = nn_function(st_c(studentData), st_c(Hospitals), 3),
         PS_hospitals_nn4 = nn_function(st_c(studentData), st_c(Hospitals), 4),
         PS_hospitals_nn5 = nn_function(st_c(studentData), st_c(Hospitals), 5))

studentData <- studentData %>%
  mutate(amenities_malls_nn1 = nn_function(st_c(studentData), st_c(ShoppingMalls), 1),
         amenities_malls_nn2 = nn_function(st_c(studentData), st_c(ShoppingMalls), 2),
         amenities_malls_nn3 = nn_function(st_c(studentData), st_c(ShoppingMalls), 3),
         amenities_malls_nn4 = nn_function(st_c(studentData), st_c(ShoppingMalls), 4),
         amenities_malls_nn5 = nn_function(st_c(studentData), st_c(ShoppingMalls), 5))

studentData <- studentData %>%
  mutate(amenities_dispensaries_nn1 = nn_function(st_c(studentData), st_c(Dispensaries), 1),
         amenities_dispensaries_nn2 = nn_function(st_c(studentData), st_c(Dispensaries), 2),
         amenities_dispensaries_nn3 = nn_function(st_c(studentData), st_c(Dispensaries), 3),
         amenities_dispensaries_nn4 = nn_function(st_c(studentData), st_c(Dispensaries), 4),
         amenities_dispensaries_nn5 = nn_function(st_c(studentData), st_c(Dispensaries), 5))
```

# Methods

## Exploratory analysis
To visually explore the data we've included some charts that will visually show the relationship between price and some of the variables that we have engineered and selected. 

```{r max_price, include=FALSE, results='hold'}
max <- max(
  studentData %>%
  filter(toPredict == 0) %>%
  select(price) %>%
  st_drop_geometry())
```


As the data is being explored, we removed the outlier `max`. This point would make some of the graphs challenging to view, because it would force the scale to be larger and as such more difficult to view the other points, because it does not accurately follow the trend of the other data.

### Price Per Square Foot
```{r}
# THIS IS WHERE WE CAN DIVERGE FROM TRAINING AND CHALLENGE DATASETS #

ggplot() +
  geom_sf(data = acsTractsCol.2019.sf, fill = "grey40") +
  geom_sf(data = studentData, aes(colour = q5(pricePerSF)), 
          show.legend = "point", size = .75) +
  scale_colour_manual(values = palette5,
                   labels=qBr(studentData,"pricePerSF"),
                   name="Quintile\nBreaks") +
  labs(title="Price Per Square Foot, Boulder County Colorado") +
  mapTheme()
```


### Visualize price by improvement age

```{r}
st_drop_geometry(studentData) %>% 
  dplyr::select(price, TotalFinishedSF, age, iprvmntAge) %>%
  filter(price <= 5000000, age < 500) %>%
  gather(Variable, Value, -price) %>% 
   ggplot(aes(Value, price)) +
     geom_point(size = .5) + geom_smooth(method = "lm", se=F, colour = "#FA7800") +
     facet_wrap(~Variable, ncol = 3, scales = "free") +
     labs(title = "Price as a function of continuous variables") +
     plotTheme()
```


### Nearest Neighbor Averages Education
For this indicator, all nearest neighbors from 1-5 were selected and averaged. This data was than summarized to find the average per MUSA code and it's associated price. These prices were than selected and plotted in the following charts. As expected the larger the average of the education variables nearest neighbor the lower the price of the property. Phrased differently, the further the property was from an educational institution the lower the price. 
```{r NN_Indicator_Education, echo=FALSE, message=FALSE, warning=FALSE}

bind_rows(
  st_drop_geometry(studentData) %>%
  filter(price < max(na.omit(studentData$price))) %>%
  select(1,MUSA_ID, intersect(starts_with("Edu"), ends_with("nn1"))) %>%
  select(!starts_with("flood_pts")) %>%
  mutate(nn = "nn1") %>%
  pivot_longer(cols = ends_with("nn1"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData) %>%
  filter(price < max(na.omit(studentData$price))) %>%
  select(1,MUSA_ID, intersect(starts_with("Edu"), ends_with("nn2"))) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn2") %>%
  pivot_longer(cols = ends_with("nn2"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData) %>%
  filter(price < max(na.omit(studentData$price))) %>%
  select(1,MUSA_ID, intersect(starts_with("Edu"), ends_with("nn3"))) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn3") %>%
  pivot_longer(cols = ends_with("nn3"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData) %>%
  filter(price < max(na.omit(studentData$price))) %>%
  select(1,MUSA_ID, intersect(starts_with("Edu"), ends_with("nn4"))) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn4") %>%
  pivot_longer(cols = ends_with("nn4"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData) %>%
  filter(price < max(na.omit(studentData$price))) %>%
  select(1,MUSA_ID, intersect(starts_with("Edu"), ends_with("nn5"))) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn5") %>%
  pivot_longer(cols = ends_with("nn5"), 
               names_to = "Amenities",
               values_to = "Distance")) %>%
  group_by(MUSA_ID, nn, price) %>%
  summarize(mean_distance = mean(Distance)) %>%
    ggplot(aes(mean_distance, price)) +
    geom_point(size = .5) +
    geom_smooth(method = "lm", se = F, colour = "#FA7800") +
    labs(title = "Education Nearest Neighbor Average and Price") +
  facet_wrap(~nn) +
    plotTheme()

```


### Nearest Neighbors Averages Amenities
The amenities indicator also calculated the nearest neighbors from 1-5 and summarized by MUSA code and its associated price. It also found that the further away an amenity is from the property the lower the property value.
```{r NN_Indicator_Amenities, echo=FALSE, message=FALSE, warning=FALSE}
bind_rows(
  st_drop_geometry(studentData) %>%
  filter(price < max(na.omit(studentData$price))) %>%
  select(1,MUSA_ID, intersect(starts_with("amenities"), ends_with("nn1"))) %>%
  select(!starts_with("flood_pts")) %>%
  mutate(nn = "nn1") %>%
  pivot_longer(cols = ends_with("nn1"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData) %>%
  filter(price < max(na.omit(studentData$price))) %>%
  select(1,MUSA_ID, intersect(starts_with("amenities"), ends_with("nn2"))) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn2") %>%
  pivot_longer(cols = ends_with("nn2"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData) %>%
  filter(price < max(na.omit(studentData$price))) %>%
  select(1,MUSA_ID, intersect(starts_with("amenities"), ends_with("nn3"))) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn3") %>%
  pivot_longer(cols = ends_with("nn3"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData) %>%
  filter(price < max(na.omit(studentData$price))) %>%
  select(1,MUSA_ID, intersect(starts_with("amenities"), ends_with("nn4"))) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn4") %>%
  pivot_longer(cols = ends_with("nn4"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData) %>%
  filter(price < max(na.omit(studentData$price))) %>%
  select(1,MUSA_ID, intersect(starts_with("amenities"), ends_with("nn5"))) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn5") %>%
  pivot_longer(cols = ends_with("nn5"), 
               names_to = "Amenities",
               values_to = "Distance")) %>%
  group_by(MUSA_ID, nn, price) %>%
  summarize(mean_distance = mean(Distance)) %>%
    ggplot(aes(mean_distance,price)) +
    geom_point(size = .5) +
    geom_smooth(method = "lm", se = F, colour = "#FA7800") +
    labs(title = "Amenities Nearest Neighbor Average and Price") +
  facet_wrap(~nn) +
    plotTheme()
```

### Nearest Neighbors Averages Public Services
THe last nearest neighbor indicator was public services. THis indicator serves the same purpose that the Amenities and Education indicator serves. The Public Services indicator showed that within the first nearest neighbor there is no decrease in price based on the distance from a public amenity; however, beyond the first nearest neighbor there is a difference in price. 
```{r NN_Indicator_PubliCServices, echo=FALSE, message=FALSE, warning=FALSE}
bind_rows(
  st_drop_geometry(studentData) %>%
  filter(price < max(na.omit(studentData$price))) %>%
  select(1,MUSA_ID, intersect(starts_with("PS"), ends_with("nn1"))) %>%
  select(!starts_with("flood_pts")) %>%
  mutate(nn = "nn1") %>%
  pivot_longer(cols = ends_with("nn1"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData) %>%
  filter(price < max(na.omit(studentData$price))) %>%
  select(1,MUSA_ID, intersect(starts_with("PS"), ends_with("nn2"))) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn2") %>%
  pivot_longer(cols = ends_with("nn2"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData) %>%
  filter(price < max(na.omit(studentData$price))) %>%
  select(1,MUSA_ID, intersect(starts_with("PS"), ends_with("nn3"))) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn3") %>%
  pivot_longer(cols = ends_with("nn3"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData) %>%
  filter(price < max(na.omit(studentData$price))) %>%
  select(1,MUSA_ID, intersect(starts_with("PS"), ends_with("nn4"))) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn4") %>%
  pivot_longer(cols = ends_with("nn4"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData) %>%
  filter(price < max(na.omit(studentData$price))) %>%
  select(1,MUSA_ID, intersect(starts_with("PS"), ends_with("nn5"))) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn5") %>%
  pivot_longer(cols = ends_with("nn5"), 
               names_to = "Amenities",
               values_to = "Distance")) %>%
  group_by(MUSA_ID, nn, price) %>%
  summarize(mean_distance = mean(Distance)) %>%
  ggplot(aes(mean_distance,price)) +
    geom_point(size = .5) +
    geom_smooth(method = "lm", se = F, colour = "#FA7800") +
    labs(title = "Public services Nearest Neighbor Average and Price") +
  facet_wrap(~nn) +
    plotTheme()
```

### Price by School District

From the school district data, there are differences between different school distrcits and the price of the property. For example, district 1 and distrcit four have much higher property values than district three and two. This bar graph shows that in our model, we should consider the role the school distrcit has in predicting the price of the property. 

```{r}
st_drop_geometry(studentData) %>%
  select(price, District) %>%
  filter(price <= 5000000) %>%
  ggplot(aes(price, District)) +
  geom_bar(aes(fill = District), position = "dodge", stat = "summary", fun.y = "mean") +
  plotTheme()
```


### Price by Zip code
While it can be argued the zip code is correlated with school distrcit, zip codes provide more nuanced data and are more publically discussed than are census tracts. In this case there are a range of property price differences from each of the zip codes. Zip30 and and zip1 have higher values in comparison to the other zips. It is unclear if this is a random trend; however, there are stark enough differences in price, that it should be considered in the model.


```{r}
st_drop_geometry(studentData) %>%
  select(price, Zip) %>%
  filter(price <= 5000000) %>%
  ggplot(aes(price, Zip)) +
  geom_bar(aes(fill = Zip), position = "dodge", stat = "summary", fun.y = "mean") +
  plotTheme()

ggplot() +
  geom_sf(data = acsTractsCol.2019.sf,
          aes(fill = White_Quartile)) +
  geom_sf(data = studentData %>% na.omit() %>% filter(price < 5000000), 
          aes(color = price)) +
  scale_color_steps(low="white", high="black", n.breaks = 5)
  labs(title = "White Quartile") +
  mapTheme()

```


### Price by Racial Quartile
In engineering new data, we transformed census tracts racial categories by quartile to take into account how people from similar racial and ethnic backgrounds move to the similar locations.

#### White Quartile
The white quartile seemed to contradict general trends [CITE]. It appears that the less white people there were the higher the price of the property.  
```{r echo=FALSE}
st_drop_geometry(studentData) %>%
  select(price, White_Quartile) %>%
  filter(price <= 5000000) %>%
  ggplot(aes(price, White_Quartile)) +
  geom_bar(aes(fill = White_Quartile),position = "dodge", stat = "summary", fun.y = "mean") +
  plotTheme()

ggplot() +
  geom_sf(data = acsTractsCol.2019.sf,
          aes(fill = White_Quartile)) +
  geom_sf(data = studentData, 
          aes(color = price)) +
  labs(title = "White Quartile") +
  mapTheme()

```


#### Black Quartile

In contrast, to Black populations, in census tracts where there were median amounts of Black people, the housing prices were higher. 
```{r}
st_drop_geometry(studentData) %>%
  select(price, Black_Quartile) %>%
  filter(price <= 5000000) %>%
  ggplot(aes(price, Black_Quartile)) +
  geom_bar(aes(fill = Black_Quartile),position = "dodge", stat = "summary", fun.y = "mean") +
  plotTheme()

ggplot() +
  geom_sf(data = acsTractsCol.2019.sf,
          aes(fill = Black_Quartile)) +
  geom_sf(data = studentData, 
          aes(color = price)) +
  labs(title = "Black Quartile") +
  mapTheme()
```


#### Asian Quartile
The Asian Qaurtile provided the most stark differences in property values. Similar to white populations, where there were less Asians showed to be higher prices; however, it is important to note that in areas with many Asians the price still seemed to be high. 

```{r}
st_drop_geometry(studentData) %>%
  select(price, Asian_Quartile) %>%
  filter(price <= 5000000) %>%
  ggplot(aes(price, Asian_Quartile)) +
  geom_bar(aes(fill = Asian_Quartile),position = "dodge", stat = "summary", fun.y = "mean") +
  plotTheme()

ggplot() +
  geom_sf(data = acsTractsCol.2019.sf,
          aes(fill = Asian_Quartile)) +
  geom_sf(data = studentData, 
          aes(color = price)) +
  labs(title = "Asian Quartile") +
  mapTheme()
```

```{r eval=FALSE, include=FALSE}
st_drop_geometry(studentData) %>%
  select(price, White_Quartile ) %>%
  filter(price <= 5000000) %>%
  ggplot(aes(price, White_Quartile )) +
  geom_bar(position = "dodge", stat = "summary", fun.y = "mean")


#### American Indian Quartile
Finally in populations where there were less American Indians, there tended to be higher housing prices.

```{r}
st_drop_geometry(studentData) %>%
  select(price, American_Indian_Quartile) %>%
  filter(price <= 5000000) %>%
  ggplot(aes(price, American_Indian_Quartile)) +
  geom_bar(aes(fill = American_Indian_Quartile),position = "dodge", stat = "summary", fun.y = "mean") +
  plotTheme()

ggplot() +
  geom_sf(data = acsTractsCol.2019.sf,
          aes(fill = American_Indian_Quartile)) +
  geom_sf(data = studentData, 
          aes(color = price)) +
  labs(title = "American Indian Quartile") +
  mapTheme()
```

Although this report has brought about some fascinating findings around race, the intent of this report is to portray the differences in price across race and how these findings can be used to inform our model. It is clear that race is a factor in our model, and as such it will be included in the final predictive model. 

# Predictive Model Development

To develop our pricing model, we will be using multiple regression and cross-validation & goodness of fit to validate our model. 

```{r message=FALSE, warning=FALSE, results='hold'}
studentData.training <- studentData %>%
    filter(toPredict == 0)

studentData.challenge <- studentData %>%
    filter(toPredict == 1)

A <- bind_rows(
  st_drop_geometry(studentData) %>%
  filter(price < max(studentData$price)) %>%
  select(1,MUSA_ID, starts_with("Edu")) %>%
  select(!starts_with("flood_pts")) %>%
  mutate(nn = "nn1") %>%
  pivot_longer(cols = ends_with("nn1"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData) %>%
  filter(price < max(studentData$price)) %>%
  select(1,MUSA_ID, starts_with("Edu")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn2") %>%
  pivot_longer(cols = ends_with("nn2"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.training) %>%
  filter(price < max(studentData.training$price)) %>%
  select(1,MUSA_ID, starts_with("Edu")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn3") %>%
  pivot_longer(cols = ends_with("nn3"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.training) %>%
  filter(price < max(studentData.training$price)) %>%
  select(1,MUSA_ID, starts_with("Edu")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn4") %>%
  pivot_longer(cols = ends_with("nn4"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.training) %>%
  filter(price < max(studentData.training$price)) %>%
  select(1,MUSA_ID, starts_with("Edu")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn5") %>%
  pivot_longer(cols = ends_with("nn5"), 
               names_to = "Amenities",
               values_to = "Distance")) %>%
  group_by(MUSA_ID) %>%
  summarize(Edu_mean_distance = mean(Distance))

studentData.training <- left_join(studentData.training, A, by = "MUSA_ID")

A <- bind_rows(
  st_drop_geometry(studentData) %>%
  filter(price < max(studentData$price)) %>%
  select(1,MUSA_ID, starts_with("amenities")) %>%
  select(!starts_with("flood_pts")) %>%
  mutate(nn = "nn1") %>%
  pivot_longer(cols = ends_with("nn1"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData) %>%
  filter(price < max(studentData$price)) %>%
  select(1,MUSA_ID, starts_with("amenities")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn2") %>%
  pivot_longer(cols = ends_with("nn2"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.training) %>%
  filter(price < max(studentData.training$price)) %>%
  select(1,MUSA_ID, starts_with("amenities")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn3") %>%
  pivot_longer(cols = ends_with("nn3"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.training) %>%
  filter(price < max(studentData.training$price)) %>%
  select(1,MUSA_ID, starts_with("amenities")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn4") %>%
  pivot_longer(cols = ends_with("nn4"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.training) %>%
  filter(price < max(studentData.training$price)) %>%
  select(1,MUSA_ID, starts_with("amenities")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn5") %>%
  pivot_longer(cols = ends_with("nn5"), 
               names_to = "Amenities",
               values_to = "Distance")) %>%
  group_by(MUSA_ID) %>%
  summarize(amenities_mean_distance = mean(Distance))

studentData.training <- left_join(studentData.training, A, by = "MUSA_ID")

A <- bind_rows(
  st_drop_geometry(studentData) %>%
  filter(price < max(studentData$price)) %>%
  select(1,MUSA_ID, starts_with("PS")) %>%
  select(!starts_with("flood_pts")) %>%
  mutate(nn = "nn1") %>%
  pivot_longer(cols = ends_with("nn1"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData) %>%
  filter(price < max(studentData$price)) %>%
  select(1,MUSA_ID, starts_with("PS")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn2") %>%
  pivot_longer(cols = ends_with("nn2"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.training) %>%
  filter(price < max(studentData.training$price)) %>%
  select(1,MUSA_ID, starts_with("PS")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn3") %>%
  pivot_longer(cols = ends_with("nn3"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.training) %>%
  filter(price < max(studentData.training$price)) %>%
  select(1,MUSA_ID, starts_with("PS")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn4") %>%
  pivot_longer(cols = ends_with("nn4"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.training) %>%
  filter(price < max(studentData.training$price)) %>%
  select(1,MUSA_ID, starts_with("PS")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn5") %>%
  pivot_longer(cols = ends_with("nn5"), 
               names_to = "Amenities",
               values_to = "Distance")) %>%
  group_by(MUSA_ID) %>%
  summarize(PS_mean_distance = mean(Distance))

studentData.training <- left_join(studentData.training, A, by = "MUSA_ID")

```
## Correlation matrix

To begin this process we first needed to determine what data was strongly correlated. Our definition of strongly correlated were any values that were greater the 0.7 and less the -0.7. These values were removed because they would not provide any new information to the model because they shared similarities to other values in the data set. The correlation table only captures variables that are numeric. Next, we selected all the pairs of variables that had values between 0.6 and 0.3, and -0.6 and -0.3. These pairs of values were then sorted through to find only the unique combinations. From the unique combination of correlated pairs, we only selected the pairs that were correlated to price. 

In addition to these numeric values we also included the categorical variables: race, zip code and school distrcit. 

```{r message=FALSE, warning=FALSE, results='hold'}
numericVars <- studentData.training %>%
                  select(!contains("grocery")) %>%
                  select(!contains("restaurant")) %>%
                  select(!contains("Education")) %>%
                  select(!contains("Museums")) %>%
                  select(!contains("Library")) %>%
                  select(!contains("recreation")) %>%
                  select(!contains("pd")) %>%
                  select(!contains("fd_emt")) %>%
                  select(!contains("hospitals")) %>%
                  select(!contains("malls")) %>%
                  select(!contains("dispensaries")) %>%
                  select(!starts_with("qualityCode"))

numericVars <- 
  st_drop_geometry(numericVars) %>% 
  select(where(is.numeric)) %>%
  na.omit()

numericVars$Edu_mean_distance <- as.integer(numericVars$Edu_mean_distance)
numericVars$amenities_mean_distance <- as.integer(numericVars$amenities_mean_distance)
numericVars$PS_mean_distance <- as.integer(numericVars$PS_mean_distance)


numericVars <- numericVars %>%
  na.omit()

ggcorrplot(
  round(cor(numericVars), 1), 
  p.mat = cor_pmat(numericVars),
  colors = c("#25CB10", "white", "#FA7800"),
  type="lower",
  insig = "blank") +  
    labs(title = "Correlation across numeric variables")

#trying to find variables that have a correlation value between 0.5 and -0.5
res <- as.data.frame(cor(numericVars)) %>%
rownames_to_column()

#pivot longer and sort through list 

A <- res %>%
  select(!c("bldgClass","toPredict")) %>%
  slice(-c(6,21)) %>%
  pivot_longer(2:(ncol(res)-2)) %>%
  filter(value >= 0.3 & value <0.6)

B <- res %>%
  select(!c("bldgClass","toPredict")) %>%
  slice(-c(6,21)) %>%
  pivot_longer(2:(ncol(res)-2)) %>%
  filter(value >= -0.6 & value < -0.3)

corlist <- bind_rows(A,B)

corlist <- corlist %>%
  group_by(value) %>%
  arrange(desc(value))

#all odd numbers between 1 and 80
keep <- c(1:nrow(corlist))
keep <- which(keep %% 2 == 1)

corlist <- corlist %>%
             slice(keep) 

# includes all correlated with price
priceCor <- corlist %>%
  filter(rowname == "price")

keep <- priceCor$name

categorical <- colnames(studentData %>%
  select(where(is.factor)) %>%
    st_drop_geometry())
  

categorical <- c("Zip","District","price")
keep <- append(keep, categorical)

```

### Multiple regression

```{r message=FALSE, warning=FALSE, results='hold'}
studentData.training %>%
  select(keep)

reg1 <- lm(price ~ ., data = st_drop_geometry(studentData.training) %>% 
       dplyr::select(keep))

summary(reg1)

```


### Testing accuracy using MAE & MAPE
```{r message=FALSE, warning=FALSE, results='hold'}
set.seed(5)

inTrain <- createDataPartition(
              y = paste(studentData.training$district,
                        studentData.training$designCode,
                        studentData.training$Zip),
              times = 1,
              p = .70, 
              list = FALSE)

training <- studentData.training[inTrain,] 
test <- studentData.training[-inTrain,]  

keep <- append(keep, "District")
reg.training <- lm(price ~ ., data = st_drop_geometry(training) %>% 
                                    dplyr::select(keep))

summary(reg.training)

test <- test %>%
  mutate(SalePrice.Predict = predict(reg.training, test),
         SalePrice.Error = SalePrice.Predict - price,
         SalePrice.AbsError = abs(SalePrice.Predict - price),
         SalePrice.APE = (abs(SalePrice.Predict - price)) / SalePrice.Predict)

mae <- mean(test$SalePrice.AbsError, na.rm=TRUE)
print(mae)
mape <- mean(test$SalePrice.APE, na.rm=TRUE)
print(mape)


# Predict house prices for training data
studentData.training <- studentData.training %>%
  mutate(SalePrice.Predict = predict(reg.training, studentData.training))


# Create list for models
models <- list()
models[['NoSD']] <- reg1
models[['SD']] <- reg.training

# Table of regression outputs
modelsummary(models, output = "kableExtra", stars = TRUE, gof_omit = 'IC|Log|AIC|BIC')
```

### Do prices and errors cluster - spatial lag & testing for SA in our current model
```{r, results='hold'}
coords.test <-  st_coordinates(test) 

neighborList.test <- knn2nb(knearneigh(coords.test, 5))

spatialWeights.test <- nb2listw(neighborList.test, style="W")

test %>% 
  mutate(lagPriceError = lag.listw(spatialWeights.test, SalePrice.Error)) %>%
  ggplot(aes(lagPriceError, SalePrice.Error)) +
  geom_point(color = "orange") +
  geom_abline(color = "dark green",
              size = 1) + 
  labs(title = "Error as a function of the spatial lag of price") +
  plotTheme()

```


### Moran's I
```{r, results='hold'}
moranTest <- moran.mc(test$SalePrice.Error, 
                      spatialWeights.test, nsim = 999)

ggplot(as.data.frame(moranTest$res[c(1:999)]), aes(moranTest$res[c(1:999)])) +
  geom_histogram(binwidth = 0.01) +
  geom_vline(aes(xintercept = moranTest$statistic), colour = "#FA7800",size=1) +
  scale_x_continuous(limits = c(-1, 1)) +
  labs(title="Observed and permuted Moran's I",
       subtitle= "Observed Moran's I in orange",
       x="Moran's I",
       y="Count") +
  plotTheme()
```

### MAPE by neighborhood
```{r}
test <- test %>%
  st_join(., acsZipsCol.2019.sf, join=st_intersects) %>%
  dplyr::select(!c(127:160))


st_drop_geometry(test) %>%
  group_by(GEOID.x) %>%
  summarize(mean.MAPE = mean(SalePrice.APE, na.rm = T)) %>%
  ungroup() %>% 
  left_join(acsZipsCol.2019.sf, by = c("GEOID.x" = "GEOID")) %>%
    st_sf() %>%
    ggplot() + 
      geom_sf(aes(fill = mean.MAPE)) +
      geom_sf(data = test, colour = "black", size = .5) +
      scale_fill_gradient(low = palette5[1], high = palette5[5],
                          name = "MAPE") +
      labs(title = "Mean test set MAPE by neighborhood") +
      mapTheme()
```


### CHALLENGE SET
```{r message=FALSE, warning=FALSE}
studentData.challenge <- studentData %>%
    filter(toPredict == 1)

A <- bind_rows(
  st_drop_geometry(studentData.challenge) %>%
  select(MUSA_ID, starts_with("Edu")) %>%
  select(!starts_with("flood_pts")) %>%
  mutate(nn = "nn1") %>%
  pivot_longer(cols = ends_with("nn1"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.challenge) %>%
  select(MUSA_ID, starts_with("Edu")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn2") %>%
  pivot_longer(cols = ends_with("nn2"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.challenge) %>%
  select(MUSA_ID, starts_with("Edu")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn3") %>%
  pivot_longer(cols = ends_with("nn3"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.challenge) %>%
  select(MUSA_ID, starts_with("Edu")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn4") %>%
  pivot_longer(cols = ends_with("nn4"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.challenge) %>%
  select(MUSA_ID, starts_with("Edu")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn5") %>%
  pivot_longer(cols = ends_with("nn5"), 
               names_to = "Amenities",
               values_to = "Distance")) %>%
  group_by(MUSA_ID) %>%
  summarize(Edu_mean_distance = mean(Distance))

studentData.challenge <- left_join(studentData.challenge, A, by = "MUSA_ID")

A <- bind_rows(
  st_drop_geometry(studentData.challenge) %>%
  select(MUSA_ID, starts_with("amenities")) %>%
  select(!starts_with("flood_pts")) %>%
  mutate(nn = "nn1") %>%
  pivot_longer(cols = ends_with("nn1"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData) %>%
  select(MUSA_ID, starts_with("amenities")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn2") %>%
  pivot_longer(cols = ends_with("nn2"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.challenge) %>%
  select(MUSA_ID, starts_with("amenities")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn3") %>%
  pivot_longer(cols = ends_with("nn3"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.challenge) %>%
  select(MUSA_ID, starts_with("amenities")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn4") %>%
  pivot_longer(cols = ends_with("nn4"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.challenge) %>%
  select(MUSA_ID, starts_with("amenities")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn5") %>%
  pivot_longer(cols = ends_with("nn5"), 
               names_to = "Amenities",
               values_to = "Distance")) %>%
  group_by(MUSA_ID) %>%
  summarize(amenities_mean_distance = mean(Distance))

studentData.challenge <- left_join(studentData.challenge, A, by = "MUSA_ID")

A <- bind_rows(
  st_drop_geometry(studentData.challenge) %>%
  select(MUSA_ID, starts_with("PS")) %>%
  select(!starts_with("flood_pts")) %>%
  mutate(nn = "nn1") %>%
  pivot_longer(cols = ends_with("nn1"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData) %>%
  select(MUSA_ID, starts_with("PS")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn2") %>%
  pivot_longer(cols = ends_with("nn2"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.challenge) %>%
  select(MUSA_ID, starts_with("PS")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn3") %>%
  pivot_longer(cols = ends_with("nn3"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.challenge) %>%
  select(MUSA_ID, starts_with("PS")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn4") %>%
  pivot_longer(cols = ends_with("nn4"), 
               names_to = "Amenities",
               values_to = "Distance"),
  st_drop_geometry(studentData.challenge) %>%
  select(MUSA_ID, starts_with("PS")) %>%
  select(!starts_with("flood_pts")) %>%
      mutate(nn = "nn5") %>%
  pivot_longer(cols = ends_with("nn5"), 
               names_to = "Amenities",
               values_to = "Distance")) %>%
  group_by(MUSA_ID) %>%
  summarize(PS_mean_distance = mean(Distance))

studentData.challenge <- left_join(studentData.challenge, A, by = "MUSA_ID")

# Predict house prices for challenge data set
studentData.challenge <- studentData.challenge %>%
  mutate(SalePrice.Predict = predict(reg.training, studentData.challenge))


# Write challenge predictions to a csv
# predictions <- studentData.challenge %>%
#   st_drop_geometry() %>%
#   select(MUSA_ID, SalePrice.Predict) %>%
#   dplyr::rename(price = SalePrice.Predict) 
# 
# write.csv(predictions, "john2.csv")

```

### Predicted home prices as a function of actual home price
```{r}
studentData.training %>%
  select(SalePrice.Predict, price) %>%
  filter(price < 3000000) %>%
  ggplot(aes(price, SalePrice.Predict)) +
  geom_point(color = "orange") +
  geom_abline(color = "dark green",
              size = 1) + 
  labs(title = "Predicted home prices as a function of actual home price") +
  plotTheme()

##################### OR ############################ 

studentData.training %>%
  select(SalePrice.Predict, price) %>%
  ggplot(aes(price, SalePrice.Predict)) +
  geom_point(color = "orange") +
  geom_abline(color = "dark green",
              size = 1) + 
  labs(title = "Predicted home prices as a function of actual home price") +
  plotTheme()
  
```



### Map of Predicted home prices
```{r}
totalPredictions <- rbind(studentData.challenge %>% select(SalePrice.Predict, price), 
                          studentData.training %>% select(SalePrice.Predict, price))


ggplot() +
  geom_sf(data = acsZipsCol.2019.sf, fill = "grey40") +
  geom_sf(data = totalPredictions %>% filter(SalePrice.Predict< 1500000), aes(colour = SalePrice.Predict), 
          show.legend = "point", size = .75) +
  scale_color_steps(low="yellow", high="red", n.breaks = 8)  +
  labs(title="Predicted House Price, Boulder County Colorado") +
  mapTheme()
```

```{r}
weirdPred <- totalPredictions %>%
  filter(SalePrice.Predict < 0)
```




# Results

# Discussion

Overall, this model is not very effective. Although the error in the model is about `r mean(test$SalePrice.APE) * 100`%, the error is large enough that if someone were to use this model, they could purchase two properties. The most interesting variables that we found were the racial categories, because they challenged our own assumptions of what the prices would be. The adjusted p-value in our model is 0.5519, which accounts for about half of the variation in the model. Our model was impacted by spatial autocorrelation, as it does appear that our geographic locations are not randomly distributed. 

# Conclusion

# Appendix AKA Code hoarding because we have a problem

### Drafts for Race data
```{r Race_dontrun, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
#once again did more work then needed, but the point is it works and this doesn't

# I did more work than I had to. I'm remaking this to just have factored quartiles. This block does not run so no worries. 


#q3 is the census tracts that have a median amount of white people. As a fixed effect, this would say for census tracts with the median amount of white people, what does the price look like?
#q4_5 is census tracts that have above the median amount of white people. 
#q1_3 is census tracts that have less then the median amount of white people

#This disadvantage to using fixed effects is that they have to be binary, either they do or do not contain something, so in the case of race I used below the median, above the median and median as binaried functions. 

White <- acsTractsCol.2019.sf %>% 
  select(GEOID, White_pop) %>%
  mutate(White_Quartile = q5(acsTractsCol.2019.sf$White_pop))

f <- studentData %>%
  mutate(
    white = as.integer(st_intersects(geometry,White)))

Black <- acsTractsCol.2019.sf %>% 
  select(GEOID, Black_pop) %>%
  mutate(Black_Quartile = q5(acsTractsCol.2019.sf$Black_pop))

Asian <- acsTractsCol.2019.sf %>% 
  select(GEOID, Asian_pop) %>%
  mutate(Asian_Quartile = q5(acsTractsCol.2019.sf$Asian_pop))

American_Indian <- acsTractsCol.2019.sf %>% 
  select(GEOID, American_Indian_pop) %>%
  mutate(American_Indian_Quartile = q5(acsTractsCol.2019.sf$American_Indian_pop))

Hawiian_PI <- acsTractsCol.2019.sf %>% 
  select(GEOID, Hawiian_PI_pop) %>%
  mutate(Hawiian_PI_Quartile = q5(acsTractsCol.2019.sf$Hawiian_PI_pop))

OtherRace <- acsTractsCol.2019.sf %>% 
  select(GEOID, OtherRace_pop) %>%
  mutate(OtherRace_Quartile = q5(acsTractsCol.2019.sf$OtherRace_pop))

two_or_more <- acsTractsCol.2019.sf %>% 
  select(GEOID, two_or_more_pop) %>%
  mutate(two_or_more_Quartile = q5(acsTractsCol.2019.sf$two_or_more_pop))

two_other <- acsTractsCol.2019.sf %>% 
  select(GEOID, two_other_pop) %>%
  mutate(two_other_Quartile = q5(acsTractsCol.2019.sf$two_other_pop))

two_or_more_exclude <- acsTractsCol.2019.sf %>% 
  select(GEOID, two_or_more_exclude_pop) %>%
  mutate(two_or_more_exclude_Quartile = q5(acsTractsCol.2019.sf$two_or_more_exclude_pop))

# I did more work than I had to. I'm remaking this to just have factored quartiles. This block does not run so no worries.

White <- acsTractsCol.2019.sf %>% 
  select(GEOID, White_pop) %>%
  mutate(Quartile = as.numeric(q5(acsTractsCol.2019.sf$White_pop)),
         Race_Whiteq3 = ifelse(Quartile == 3, TRUE, FALSE),
         Race_Whiteq4_5 = ifelse(Quartile > 3, TRUE, FALSE),
         Race_Whiteq1_2 = ifelse(Quartile < 3, TRUE, FALSE))

Black <- acsTractsCol.2019.sf %>% 
  select(GEOID, Black_pop) %>%
  mutate(Quartile = as.numeric(q5(acsTractsCol.2019.sf$Black_pop)),
         Race_Blackq3 = ifelse(Quartile == 3, TRUE, FALSE),
         Race_Blackq4_5 = ifelse(Quartile > 3, TRUE, FALSE),
         Race_Blackq1_2 = ifelse(Quartile < 3, TRUE, FALSE))

Asian <- acsTractsCol.2019.sf %>% 
  select(GEOID, Asian_pop) %>%
  mutate(Quartile = as.numeric(q5(acsTractsCol.2019.sf$Asian_pop)),
         Race_Asianq3 = ifelse(Quartile == 3, TRUE, FALSE),
         Race_Asianq4_5 = ifelse(Quartile > 3, TRUE, FALSE),
         Race_Asianq1_2 = ifelse(Quartile < 3, TRUE, FALSE))

American_Indian <- acsTractsCol.2019.sf %>% 
  select(GEOID, American_Indian_pop) %>%
  mutate(Quartile = as.numeric(q5(acsTractsCol.2019.sf$American_Indian_pop)),
         Race_American_Indianq3 = ifelse(Quartile == 3, TRUE, FALSE),
         Race_American_Indianq4_5 = ifelse(Quartile > 3, TRUE, FALSE),
         Race_American_Indianq1_2 = ifelse(Quartile < 3, TRUE, FALSE))

Hawiian_PI <- acsTractsCol.2019.sf %>% 
  select(GEOID, Hawiian_PI_pop) %>%
  mutate(Quartile = as.numeric(q5(acsTractsCol.2019.sf$Hawiian_PI_pop)),
         Race_Hawiian_PIq3 = ifelse(Quartile == 3, TRUE, FALSE),
         Race_Hawiian_PIq4_5 = ifelse(Quartile > 3, TRUE, FALSE),
         Race_Hawiian_PIq1_2 = ifelse(Quartile < 3, TRUE, FALSE))

OtherRace <- acsTractsCol.2019.sf %>% 
  select(GEOID, OtherRace_pop) %>%
  mutate(Quartile = as.numeric(q5(acsTractsCol.2019.sf$OtherRace_pop)),
         RaceOther_Raceq3 = ifelse(Quartile == 3, TRUE, FALSE),
         RaceOther_Raceq4_5 = ifelse(Quartile > 3, TRUE, FALSE),
         RaceOther_Raceq1_2 = ifelse(Quartile < 3, TRUE, FALSE))

two_or_more <- acsTractsCol.2019.sf %>% 
  select(GEOID, two_or_more_pop) %>%
  mutate(Quartile = as.numeric(q5(acsTractsCol.2019.sf$two_or_more_pop)),
         Race_two_or_moreq3 = ifelse(Quartile == 3, TRUE, FALSE),
         Race_two_or_moreq4_5 = ifelse(Quartile > 3, TRUE, FALSE),
         Race_two_or_moreq1_2 = ifelse(Quartile < 3, TRUE, FALSE))

two_other <- acsTractsCol.2019.sf %>% 
  select(GEOID, two_other_pop) %>%
  mutate(Quartile = as.numeric(q5(acsTractsCol.2019.sf$two_other_pop)),
         Race_two_otherq3 = ifelse(Quartile == 3, TRUE, FALSE),
         Race_two_otherq4_5 = ifelse(Quartile > 3, TRUE, FALSE),
         Race_two_otherq1_2 = ifelse(Quartile < 3, TRUE, FALSE))

two_or_more_exclude <- acsTractsCol.2019.sf %>% 
  select(GEOID, two_or_more_exclude_pop) %>%
  mutate(Quartile = as.numeric(q5(acsTractsCol.2019.sf$two_or_more_exclude_pop)),
         Race_two_or_more_excludeq3 = ifelse(Quartile == 3, TRUE, FALSE),
         Race_two_or_more_excludeq4_5 = ifelse(Quartile > 3, TRUE, FALSE),
         Race_two_or_more_excludeq1_2 = ifelse(Quartile < 3, TRUE, FALSE))

```

### Checking how school distrcits work
```{r eval=FALSE, include=FALSE}
# I'm trying to check how the distrcit groups are made, and it looks like they are in order from the rows they were assigned. 

studentData %>%
  st_drop_geometry() %>%
  group_by(District) %>%
  summarize(Freq = n())

ggplot() +
  geom_sf(data = acsSchoolDistrctssCol.2019.sf,
          aes(fill = id)) +
  geom_sf(data = studentData %>%
            filter(District == "District1"),
          color = "Red") +
  geom_sf(data = studentData %>%
            filter(District == "District4"),
          color = "Black")
```

### Boulder City Fixed Effect

```{r city_Limits, eval=FALSE, include=FALSE, results='hide'}
boulderCityLimits <- st_read("https://opendata.arcgis.com/datasets/955e7a0f52474b60a9866950daf10acb_0.geojson") %>%
  st_transform(st_crs(acsTractsCol.2019.sf)) %>%
  mutate(inCity = 1)

# Determine if a house is within the city or not - used for cases in which only city data is available
studentData <- studentData %>%
  mutate(withinCity = as.integer(st_intersects(geometry,boulderCityLimits)))

studentData <- studentData %>%
  mutate(withinCity = replace_na(withinCity,"0"))

# Change 
#studentData <- studentData %>%
#  mutate(withinCity = ifelse(withinCity > 0, 1, 0))

#zips <- c(80301:80305)
#zips <- as.character(zips)

#ggplot() +
#  geom_sf(data = acsZipsCol.2019.sf %>%
#            filter(GEOID %in% zips)) +
#  geom_sf(data = studentData) +
#  geom_sf(data = boulderCityLimits,
#          fill = "transparent",
#          border = 2)
```



### Rental Properties
```{r colorado_data, eval=FALSE, message=TRUE, warning=FALSE, include=FALSE}

# # Locations of Rental Properties (by license)
# ## https://open-data.bouldercolorado.gov/datasets/92f70ea894ef47a582bb0d656aa4aa7d_0/explore?location=40.013774%2C-105.256817%2C16.81
# rentalHomes <- st_read("https://opendata.arcgis.com/datasets/92f70ea894ef47a582bb0d656aa4aa7d_0.geojson") %>%
#   st_transform(CO_statePlaneCentral)
# 
# ggplot() +
#   geom_sf(data = st_union(acsTractsCol.2019.sf),
#           fill = "transparent") +
#   geom_sf(data = st_centroid(rentalHomes)) +
#   labs(title = "Rental Homes")
# 
# 
# # Locations of Accessory Dwelling Units
# ## https://open-data.bouldercolorado.gov/datasets/669935e6d13c406497cd9cbbbd7951b2_0/explore?location=40.023716%2C-105.253583%2C11.91
# ## For explanation on what ADU's are: https://planning.org/knowledgebase/accessorydwellings/ 
# adus <- st_read("https://opendata.arcgis.com/datasets/669935e6d13c406497cd9cbbbd7951b2_0.geojson") %>%
#   st_transform(CO_statePlaneCentral)
# 
# ggplot() +
#   geom_sf(data = st_union(acsTractsCol.2019.sf),
#           fill = "transparent") +
#   geom_sf(data = adus) +
#   labs(title = "Accessory Dwelling Units")
# 
# 
```


### Parks and Trees
```{r eval=FALSE, include=FALSE}
#addresses for buildings https://open-data.bouldercolorado.gov/datasets/d63e537da54640bd967c2fedc4c99a92_0/explore?location=40.026211%2C-105.232810%2C11.82 
# Addresses <- st_read("https://opendata.arcgis.com/datasets/d63e537da54640bd967c2fedc4c99a92_0.geojson") %>%
#   st_transform(CO_statePlaneCentral)
# 
# ggplot() +
#   geom_sf(data = st_union(acsTractsCol.2019.sf),
#           fill = "transparent") +
#   geom_sf(data = Addresses) +
#   labs(title = "Addresses")

# Properties managed by parks and recreation polygons ## https://open-data.bouldercolorado.gov/datasets/fdfc0410e75c48b6b9e53cf94bdbe224_1/explore?location=40.026750%2C-105.234200%2C12.05 
Parks <- st_read("https://opendata.arcgis.com/datasets/fdfc0410e75c48b6b9e53cf94bdbe224_1.geojson")
ggplot() +
  geom_sf(data = acsTractsCol.2019.sf) +
  geom_sf(data = Parks,
          fill = "pink")

# Urban trees
## https://open-data.bouldercolorado.gov/datasets/dbbae8bdb0a44d17934243b88e85ef2b_0/explore?location=40.015538%2C-105.275671%2C16.12
trees <- st_read("https://opendata.arcgis.com/datasets/dbbae8bdb0a44d17934243b88e85ef2b_0.geojson") %>%
    st_transform(CO_statePlaneCentral)

ggplot() +
  geom_sf(data = st_union(acsTractsCol.2019.sf),
          fill = "transparent") +
  geom_sf(data = trees) +
  labs(title = "Street Trees")

```

## Nearest Neighbor Plots
```{r NN_Grocery_plots, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE, results='hold'}
st_drop_geometry(studentData) %>%
  filter(toPredict == 0) %>%
  filter(price < max) %>%
  select(1,MUSA_ID,contains("grocery")) %>%
  pivot_longer(cols = contains("grocery"), 
               names_to = "Nearest_Neighbor",
               values_to = "Distance") %>%
  group_by(Nearest_Neighbor, price) %>%
  summarize(mean_distance = mean(Distance)) %>%
  ggplot(aes(mean_distance,price)) +
    geom_point(size = .5) +
    geom_smooth(method = "lm", se = F, colour = "#FA7800") +
    facet_wrap(~Nearest_Neighbor) +
    labs(title = "Nearest Neighbor Grocery Store and Price") +
    plotTheme()
```


```{r NN_Restaurant_plots, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE, results='hold'}
st_drop_geometry(studentData) %>%
  filter(price < max) %>%
  select(1,MUSA_ID,contains("restaurant")) %>%
  pivot_longer(cols = contains("restaurant"), 
               names_to = "Nearest_Neighbor",
               values_to = "Distance") %>%
  group_by(Nearest_Neighbor, price) %>%
  summarize(mean_distance = mean(Distance)) %>%
  ggplot(aes(mean_distance,price)) +
    geom_point(size = .5) +
    geom_smooth(method = "lm", se = F, colour = "#FA7800") +
    facet_wrap(~Nearest_Neighbor) +
    labs(title = "Nearest Neighbor Restaurant and Price") +
    plotTheme()
```

```{r NN_Education_plots, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE, results='hold'}

st_drop_geometry(studentData) %>%
  filter(price < max) %>%
  select(1,MUSA_ID,contains("Education")) %>%
  pivot_longer(cols = contains("Education"), 
               names_to = "Nearest_Neighbor",
               values_to = "Distance") %>%
  group_by(Nearest_Neighbor, price) %>%
  summarize(mean_distance = mean(Distance)) %>%
  ggplot(aes(mean_distance,price)) +
    geom_point(size = .5) +
    geom_smooth(method = "lm", se = F, colour = "#FA7800") +
    facet_wrap(~Nearest_Neighbor) +
    labs(title = "Nearest Neighbor Grocery Store and Price") +
    plotTheme()
```

```{r NN_Museums_plots, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE, results='hold'}

st_drop_geometry(studentData) %>%
  filter(price < max) %>%
  select(1,MUSA_ID,contains("Museums")) %>%
  pivot_longer(cols = contains("Museums"), 
               names_to = "Nearest_Neighbor",
               values_to = "Distance") %>%
  group_by(Nearest_Neighbor, price) %>%
  summarize(mean_distance = mean(Distance)) %>%
  ggplot(aes(mean_distance,price)) +
    geom_point(size = .5) +
    geom_smooth(method = "lm", se = F, colour = "#FA7800") +
    facet_wrap(~Nearest_Neighbor) +
    labs(title = "Nearest Neighbor Grocery Store and Price") +
    plotTheme()
```


```{r ComparingNN1_plots, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE, results='hold'}

st_drop_geometry(studentData) %>%
  filter(price < max) %>%
  select(1,MUSA_ID, ends_with("nn1")) %>%
  pivot_longer(cols = ends_with("nn1"), 
               names_to = "Amenities",
               values_to = "Distance") %>%
  group_by(Amenities, price) %>%
  summarize(mean_distance = mean(Distance)) %>%
  ggplot(aes(mean_distance,price)) +
    geom_point(size = .5) +
    geom_smooth(method = "lm", se = F, colour = "#FA7800") +
    facet_wrap(~Amenities) +
    labs(title = "Nearest Neighbor 1 all Locations and Price") +
    plotTheme()
```


```{r ComparingNN2_plots, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE, results='hold'}

st_drop_geometry(studentData) %>%
  filter(price < max) %>%
  select(1,MUSA_ID, ends_with("nn2")) %>%
  pivot_longer(cols = ends_with("nn2"), 
               names_to = "Amenities",
               values_to = "Distance") %>%
  group_by(Amenities, price) %>%
  summarize(mean_distance = mean(Distance)) %>%
  ggplot(aes(mean_distance,price)) +
    geom_point(size = .5) +
    geom_smooth(method = "lm", se = F, colour = "#FA7800") +
    facet_wrap(~Amenities) +
    labs(title = "Nearest Neighbor 2 all Locations and Price") +
    plotTheme()
```

```{r ComparingNN3_plots, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE, results='hold'}

st_drop_geometry(studentData) %>%
  filter(price < max) %>%
  select(1,MUSA_ID, ends_with("nn3")) %>%
  pivot_longer(cols = ends_with("nn3"), 
               names_to = "Amenities",
               values_to = "Distance") %>%
  group_by(Amenities, price) %>%
  summarize(mean_distance = mean(Distance)) %>%
  ggplot(aes(mean_distance,price)) +
    geom_point(size = .5) +
    geom_smooth(method = "lm", se = F, colour = "#FA7800") +
    facet_wrap(~Amenities) +
    labs(title = "Nearest Neighbor 3 all Locations and Price") +
    plotTheme()
```

```{r ComparingNN4_plots, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE, results='hold'}

st_drop_geometry(studentData) %>%
  filter(price < max) %>%
  select(1,MUSA_ID, ends_with("nn4")) %>%
  pivot_longer(cols = ends_with("nn4"), 
               names_to = "Amenities",
               values_to = "Distance") %>%
  group_by(Amenities, price) %>%
  summarize(mean_distance = mean(Distance)) %>%
  ggplot(aes(mean_distance,price)) +
    geom_point(size = .5) +
    geom_smooth(method = "lm", se = F, colour = "#FA7800") +
    facet_wrap(~Amenities) +
    labs(title = "Nearest Neighbor 4 all Locations and Price") +
    plotTheme()
```

```{r ComparingNN5_plots, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE, results='hold'}

st_drop_geometry(studentData) %>%
  filter(price < max) %>%
  select(1,MUSA_ID, ends_with("nn5")) %>%
  pivot_longer(cols = ends_with("nn5"), 
               names_to = "Amenities",
               values_to = "Distance") %>%
  group_by(Amenities, price) %>%
  summarize(mean_distance = mean(Distance)) %>%
  ggplot(aes(mean_distance,price)) +
    geom_point(size = .5) +
    geom_smooth(method = "lm", se = F, colour = "#FA7800") +
    facet_wrap(~Amenities) +
    labs(title = "Nearest Neighbor 5 all Locations and Price") +
    plotTheme()
```

## Categorical Variables Plots

```{r eval=FALSE, fig.height=15, fig.width=10, message=FALSE, warning=FALSE, include=FALSE}
st_drop_geometry(studentData) %>% 
  dplyr::select(price, designCodeDscr, ConstCodeDscr, carStorageTypeDscr) %>%
  # mutate(NUM_FLOORS = as.factor(NUM_FLOORS)) %>%
  filter(price <= 5000000) %>%
  gather(Variable, Value, -price) %>% 
   ggplot(aes(Value, price)) +
     geom_bar(position = "dodge", stat = "summary", fun.y = "mean") +
     facet_wrap(~Variable, ncol = 1, scales = "free") +
     labs(title = "Price as a function of\ncategorical variables", y = "Mean_Price") +
     plotTheme() + theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## OLS OLD
#### OLS
```{r eval=FALSE, warning=FALSE, include=FALSE}
cor.test(studentData.training$Edu_mean_distance, studentData.training$price, method = "pearson")

cor.test(studentData.training$TotalFinishedSF, studentData.training$price, method = "pearson")

livingReg <- lm(price ~ TotalFinishedSF, data = studentData.training)

summary(livingReg)
```
